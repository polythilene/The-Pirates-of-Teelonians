///////////////////////////////////////////////////////////
//  CBaseTeelos.as
//  Macromedia ActionScript Implementation of the Class CBaseTeelos
//  Generated by Enterprise Architect
//  Created on:      11-Des-2010 20:47:48
//  Original author: poof!
///////////////////////////////////////////////////////////

package com.game
{
	import com.game.ai.AIState;
	import com.game.ai.AIState_Dead;
	import com.greensock.TweenMax;
	import flash.display.DisplayObjectContainer;
	import flash.display.MovieClip;
	import flash.utils.getTimer;
	import math.OpMath;
	
	/**
	 * @author poof!
	 * @version 1.0
	 * @created 11-Des-2010 20:47:48
	 */
	public class CBaseTeelos
	{
		public var prev:CBaseTeelos;
		public var next:CBaseTeelos;
		
	    protected var m_active: Boolean;
	    protected var m_baseAttack:int;
		protected var m_currAttack:int;
		
		//damage range attack for hybrid unit
		protected var m_baseRangeAttack:int;
	 
		protected var m_defense: int;
	    protected var m_maxLife: int;
		protected var m_currLife: int;
	   	protected var m_baseSpeed: Number;
		protected var m_currSpeed: Number;
	    protected var m_charge: int;
	    protected var m_unitClass: int;
	    protected var m_counterClass: int;
	    protected var m_counterBonus: int;
	    protected var m_sprite: MovieClip;
	    protected var m_lane: int;
	    protected var m_attackRange: int;
		protected var m_baseCooldownTime:int;
		protected var m_currCooldownTime:int;
	    protected var m_cooldownTime: int;
	    protected var m_cooldownCounter: int;
		protected var m_dead: Boolean;
		protected var m_target: CBaseTeelos;
		protected var m_level: int;
		protected var m_maxProjectile:int;
		protected var m_currMaxProjectile:int;
		protected var m_projCount:int;
		
		protected var m_container: DisplayObjectContainer;
		
		private var m_aiStateTime: int;
		private var m_aiLastStateTime: int;
		private var m_currAIState: AIState;
		
		private var m_targetPosX:int;
		private var m_projectileReleased:Boolean;
		
		protected var m_stealthUnit:Boolean;
		protected var m_detectInvisible:Boolean;
		protected var m_speedMultiplier:Number;
		
		// freezing
		private var m_frozen:Boolean;
		private var m_freezeTimeMax:int;
		private var m_freezeTimeCurr:int;
		private var m_freezeFactor:Number;
		
		//captain attributes
		protected var m_isPowerUp:Boolean;
		private var m_powerUpTimeMax:int;
		private var m_powerUpTimeCurr:int;
		
		protected var m_isRateUp:Boolean;
		private var m_rateUpTimeMax:int;
		private var m_rateUpTimeCurr:int;
		
		protected var m_isDoubleShot:Boolean;
		private var m_doubleShotTimeMax:int;
		private var m_doubleShotTimeCurr:int;
		
		protected var m_cloneActive:Boolean;
		protected var m_cloneTimeMax:int;
		protected var m_cloneTimeCurr:int;
		
		public var cloneLaneTarget:int;
		public var classType:Class;
		
		
		protected var m_isWalking:Boolean;
		
		public function CBaseTeelos(){
			initialize();
		}

	   	public function initialize():void
		{
			m_unitClass = UNITCLASS.INFANTRY;
			m_counterClass = UNITCLASS.NONE;
			m_baseAttack = 10;
			m_defense = 2;
			m_maxLife = 100;
			m_baseSpeed = 0.1;
			m_charge = 0;
			m_baseCooldownTime = 1500;
			m_speedMultiplier = 1;
			m_counterBonus = 0;
			
			m_stealthUnit = false;
			m_detectInvisible = false;
			
			createSprite();
			m_sprite.cacheAsBitmap = true;
			m_sprite.mouseEnabled = m_sprite.mouseChildren = false;
		}
		
		protected function createSprite():void
		{
			// ABSTRACT METHOD, IN THIS STAGE INHERITED CLASSES MUST DEFINE ITS OWN SPRITE
		}
		
	    public function onCreate(lane:int, xPos:int, container:DisplayObjectContainer): void
	    {
			m_container = container;
			
			m_active = true;
			m_attackRange = 40;
			m_cooldownCounter = 0;
			m_cooldownCounter = m_cooldownTime = m_baseCooldownTime;
			m_currLife = m_maxLife;
			m_currSpeed = m_baseSpeed;
			m_dead = false;
			m_projectileReleased = false;
			m_target = null;
			
			m_frozen = false;
			m_freezeTimeMax = 0;
			m_freezeTimeCurr = 0;
			m_freezeFactor = 0;
		
			m_lane = lane;
			switch( m_lane )
			{
				case 0: m_sprite.y = 200; break;
				case 1: m_sprite.y = 265; break;
				case 2: m_sprite.y = 325; break;
				case 3: m_sprite.y = 385; break;
				case 4: m_sprite.y = 445; break;
			}

			TweenMax.to( m_sprite, 0.1, { colorMatrixFilter: { colorize:0xFF0000, amount:0 } } );
			m_container.addChild(m_sprite);
	    }

	    public function onRemove(): void
	    {
			TweenMax.killTweensOf(m_sprite);
			m_container.removeChild(m_sprite);
			//m_sprite.parent.removeChild(m_sprite);
			//m_container = null;
	    }

	    public function attack(target:CBaseTeelos): void
	    {
			// ABSTRACT METHOD, MUST BE INHERITED
			m_target = target;
	    }
		
		public function isCoolingDown(): Boolean
	    {
			return ( m_cooldownCounter < m_cooldownTime );
	    }
		
		public function isActive(): Boolean
		{
			return m_active;
		}
		
		public function setInactive(): void
		{
			m_active = false;
		}
		
		public function isDead(): Boolean
		{
			return m_dead; 
		}
		
		public function isPowerUp():Boolean
		{
			return m_isPowerUp;
		}
		public function isRateUp():Boolean
		{
			return m_isRateUp;
		}
		public function isDoubleShot():Boolean
		{
			return m_isDoubleShot;
		}
		public function set Clone(value:Boolean):void
		{
			m_cloneActive = value;
		}
		
		public function set powerUp(value:Boolean):void
		{
			m_isPowerUp = value;
		}
		
		
		public function damage(value:int, source:CBaseTeelos):void
		{
			if ( value > 0 )
			{
				var def:int = Math.ceil( defense / 2 );
				var dmg:int = (def >= value) ? 1 : value - def;
			}
			else
			{
				dmg = value;
			}
			
			if( dmg  == 0 )
				dmg = 1;
				
			m_currLife -= dmg;
			
			
			// play sfx
			if ( dmg > 0 )
			{
				var dice:int = Math.floor(OpMath.randomNumber(100));
				if( dice < 30 )
					SoundManager.getInstance().playSFX("SN12_1");
				else if ( dice > 30 && dice < 60 )
					SoundManager.getInstance().playSFX("SN12_2");
			}
			
			if( m_currLife <= 0 && !(this is CTeeloBaseBuilding) ) //siput
			{
				dice = OpMath.randomNumber(200)
				if( dice < 50 )
					SoundManager.getInstance().playSFX("SN_dead_1");
				else if (dice > 50 && dice < 100)
					SoundManager.getInstance().playSFX("SN_dead_2");
				else if (dice > 100 && dice < 150)
					SoundManager.getInstance().playSFX("SN_dead_3");
				else if (dice > 150 && dice < 180)
					SoundManager.getInstance().playSFX("SN_dead_4");
				
				
				m_dead = true;
				changeAIState( AIState_Dead.getInstance() );
			}
			
			m_currLife = Math.min(m_currLife, m_maxLife);		// cap value when unit is healed
			
			// tint sprite
			var col:int = (value > 0) ? 0xFF0000 : 0x00FF00;
			tintOnHit(col);
		}
		
		protected function tintOnHit(color:int ):void
		{
			if ( !m_frozen )
			{
				//throw new Error("This error is on purpose!");
				TweenMax.killTweensOf( m_sprite );
				TweenMax.to( m_sprite, 0.2, { colorMatrixFilter: { colorize:color, amount:0.7 },
											  onComplete:function():void
											  {
												TweenMax.to( m_sprite, 0.3, { colorMatrixFilter: { colorize:color, amount:0 } } );
										 	  }			
											} );
			}
		}
		
		public function set x(value:Number):void
		{
			m_sprite.x = value;
		}
		
		public function get x():Number
		{
			return m_sprite.x;	
		}
			
		public function set y(value:Number):void
		{
			m_sprite.y = value;	
		}
		
		public function get y():Number
		{
			return m_sprite.y;	
		}
		
		public function get speed():Number
		{
			return m_currSpeed * m_speedMultiplier;	
		}
		
		public function setDestination(dest:int):void
		{
			m_targetPosX = dest;
		}
		
		public function set destination(value:int):void
		{
			m_targetPosX = value;
		}
		
		public function getDestination():int
		{
			return m_targetPosX;
		}
		
		public function changeAIState(newState:AIState ):void 
		{
			var currTime:int = getTimer();
		
			m_aiStateTime = 0;		// reset counter
			
			if( m_currAIState )
				m_currAIState.exit(this);
				
			m_currAIState = newState;
			m_currAIState.enter(this);
			
			m_aiLastStateTime = currTime;
		}
		
		public function setCurrentFrame(value:int):void
		{
			m_sprite.gotoAndStop(value);
			animationReset();
		}
		
		public function isDestinationReached():Boolean
		{
			var currPos:int = m_sprite.x;
			var destPos:int = m_targetPosX;
			
			
			// TODO: SOMETIMES PLAYER WILL EXCEED ITS DESTINATION POINT
			
			if( Math.abs( currPos - destPos ) < 5 )
				return true;
			
			// jika hadap kanan
			if ( m_sprite.scaleX == 1 && currPos > destPos )
			{
				m_sprite.x = destPos;
				return true;
			}
			else if ( m_sprite.scaleX == -1 && currPos < destPos )
			{
				m_sprite.x = destPos;
				return true;
			}	
				
			return false;
		}
		/*
		public function getDestinationPos():int
		{
			return m_targetPosX;
		}
		*/
		 /**
	     * 
	     * @param elapsedTime
	     */
	    public function update(elapsedTime:int): void
	    {
			m_cooldownCounter += elapsedTime;
			
			if( m_cooldownCounter > m_cooldownTime )
			{
				m_projectileReleased = false;
			}
			
			// update ai
			if( m_active && m_currAIState)
			{
				m_currAIState.update( this, elapsedTime );
			}
			m_aiStateTime += elapsedTime;	
			
			
			// update freezing
			if ( m_frozen )
			{
				m_freezeTimeCurr += elapsedTime;
				if ( m_freezeTimeCurr > m_freezeTimeMax )
				{
					m_frozen = false;
					m_freezeFactor = 0;
					TweenMax.to( m_sprite, 0.5, { colorMatrixFilter: { colorize:0x33cccc, amount:0.0 } } );
				}
			}
			
			//update power up
			if ( m_isPowerUp )
			{
				m_powerUpTimeCurr += elapsedTime;
				if (m_powerUpTimeCurr > m_powerUpTimeMax)
				{
					m_isPowerUp = false;
					m_baseAttack = m_currAttack;
					//trace("damage now:" , m_baseAttack);
				}
			}
			
			//update rate attack up
			if ( m_isRateUp )
			{
				m_rateUpTimeCurr += elapsedTime;
				if (m_rateUpTimeCurr > m_rateUpTimeMax)
				{
					m_isRateUp = false;
					m_baseCooldownTime = m_currCooldownTime;
					//trace("attack rate now:" , m_baseCooldownTime);
				}
			}
			
			//update double shot
			if (m_isDoubleShot)
			{
				m_doubleShotTimeCurr += elapsedTime;
				if (m_doubleShotTimeCurr > m_doubleShotTimeMax)
				{
					m_isDoubleShot = false;
					m_maxProjectile = m_currMaxProjectile;
				}
			}
			
			//update clone
			if (m_cloneActive)
			{
				m_cloneTimeCurr += elapsedTime;
				if (m_cloneTimeCurr > m_cloneTimeMax)
				{
					m_cloneActive = false;
					setCurrentFrame(8);
				}
			}
			
				
			// check if ai state got stuck 
			if( m_currAIState && m_currAIState.isTimeoutEnable() &&
				m_aiStateTime > m_currAIState.getTimeoutInterval() ) 
			{
				// write debug message
				trace("AI State Stuck at", m_currAIState.getStateName() );
			}
	    }
		
		public function attach():void
		{
			m_container.addChild( m_sprite );
		}
		
		public function detach():void
		{
			m_container.removeChild( m_sprite );
		}
		
		public function get laneIndex():int
		{
			return m_lane;
		}
		public function set laneIndex(value:int):void
		{
			m_lane = value;
		}
		
		public function getNearestEnemy():CBaseTeelos
		{
			return NPCManager.getInstance().getNearestEnemy(this);
		}
		
		public function isAnimationComplete():Boolean
		{
			var ret:Boolean = true;
			
			if( m_sprite.sprite != null )
				ret = ( m_sprite.sprite.currentFrame >= m_sprite.sprite.totalFrames );
			else if ( m_sprite.rank && m_sprite.rank.sprite )
				ret = ( m_sprite.rank.sprite.currentFrame >= m_sprite.rank.sprite.totalFrames );
			//else
				//trace("No sprite instance available:", this);
			
			return ret;
		}
		
		public function animationPlay():void
		{
			for (var i:int; i < 6; i++ )
			{
				m_sprite.gotoAndStop(i + 1);
				
				if( m_sprite.sprite )
					m_sprite.sprite.play();
				else if ( m_sprite.rank && m_sprite.rank.sprite )
				{
					m_sprite.rank.gotoAndStop(m_level);
					m_sprite.rank.sprite.play();	
				}
			}
		}
		
		public function animationStop():void
		{
			for (var i:int; i < 6; i++ )
			{
				m_sprite.gotoAndStop(i + 1);
				
				if( m_sprite.sprite )
					m_sprite.sprite.stop();
				else if ( m_sprite.rank && m_sprite.rank.sprite )
				{
					m_sprite.rank.gotoAndStop(m_level);
					m_sprite.rank.sprite.stop();
				}
			}
		}
		
		public function animationReset():void
		{
			if( m_sprite.sprite )
				m_sprite.sprite.gotoAndPlay(1);
			else if ( m_sprite.rank && m_sprite.rank.sprite )
			{
				m_sprite.rank.gotoAndStop(m_level);
				m_sprite.rank.sprite.gotoAndPlay(1);
			}
			//else
				//trace("No sprite instance available:", this);
		}
		
		public function get attackRange():int
		{
			return m_attackRange;
		}
		
		public function get unitClass():int
		{
			return m_unitClass;
		}
		
		// stats
		
		public function get attackDamage():int
		{
			return m_baseAttack;
		}
		public function set attackDamage(value:int):void
		{
			m_baseAttack = value;
		}
		
		
		public function get defense():int
		{
			return m_defense;
		}
		
		public function get life():int
		{
			return m_currLife;
		}
		
		public function get maxLife():int
		{
			return m_maxLife;
		}
		
		public function getFaction():int
		{
			return 0;
		}
		
		public function getSprite():MovieClip
		{
			return m_sprite;
		}
		
		public function getMaxProjectile():int
		{
			return m_maxProjectile;
		}
		public function getProjectileCount():int
		{
			return m_projCount;
		}
		public function set projCount(value:int):void 
		{
			m_projCount = value;
		}
		
		public function releaseProjectile():void
		{
			m_projectileReleased = true;
			// ABSTRACT METHOD MUST BE INHERITED FOR RANGED CLASSES
		}
		
		public function isProjectileReleased():Boolean
		{
			return m_projectileReleased;
		}
		public function isWalking():Boolean
		{
			return m_isWalking;
		}
		public function set walk(value:Boolean):void
		{
			m_isWalking = value;
		}
		
		
		public function onKilled():void
		{
			// ABSTRACT METHOD
		}
		
		public function knockBack(value:Number, tween:Boolean = false):void
		{
			if ( tween )
			{
				TweenMax.killTweensOf(m_sprite);
				TweenMax.to(m_sprite, 1.4, { x:m_sprite.x + value } );
			}
			else
			{	
				m_sprite.x += value * (m_sprite.scaleX * -1);
			}
		}
		
		public function freeze(time:int, factor:Number):void
		{
			m_frozen = true;
			m_freezeTimeMax = time;
			m_freezeTimeCurr = 0;
			m_freezeFactor = factor;
			
			// tint sprite
			TweenMax.to( m_sprite, 0.2, { colorMatrixFilter: { colorize:0x33cccc, amount:0.7 } } );
		}
		
		public function PowerUP(duration:int , factor:int):void
		{
			m_isPowerUp = true;
			m_powerUpTimeMax = duration;
			m_powerUpTimeCurr = 0;
			
			m_baseAttack *= factor;
			//trace("damage become:" , m_baseAttack);
			//m_currAttack = m_baseAttack;
			
		}
		
		public function SpeedUP(duration:int , factor:int):void
		{
			m_isRateUp= true;
			m_rateUpTimeMax = duration;
			m_rateUpTimeCurr = 0;
			
			m_baseCooldownTime /= factor;
			
			//trace("attack rate become:" , m_baseCooldownTime);
			//m_currAttack = m_baseAttack;	
		}
		
		public function Heal():void
		{
			m_currLife = m_maxLife;
		}
		
		public function doubleSHOT(duration:int , factor:int):void
		{
			m_isDoubleShot = true;
			m_doubleShotTimeMax = duration;
			m_doubleShotTimeCurr = 0;
			
			m_maxProjectile *= factor;
			
			//m_currAttack = m_baseAttack;	
		}
		
		public function isFrozen():Boolean
		{
			return m_frozen;
		}
		
		public function get slowFactor():Number
		{
			return m_freezeFactor;
		}
		
		public function get lifePercentage():Number
		{
			return m_currLife / m_maxLife;
		}
		
		public function isStealthUnit():Boolean
		{
			return m_stealthUnit;
		}
		
		public function detectInvisible():Boolean
		{
			return m_detectInvisible;
		}
		
		public function animationHit():void
		{
			// ABSTRACT METHOD
		}
		
		public function get container():DisplayObjectContainer
		{
			return m_container;
		}
		
		public function getLevel():int
		{
			return m_level;
		}
		
		public function isPointCollide(x:int, y:int):Boolean
		{
			return m_sprite.hitTestPoint(x, y);
		}
		
		public function setDirection(dir:int):void
		{
			m_sprite.scaleX = dir;
		}
		
		public function getDirection():int
		{
			return m_sprite.scaleX;
		}
		
		public function setLevel(value:int):void
		{
			m_level = value;
		}
		
		public function refreshLife():void
		{
			m_currLife = m_maxLife + m_level - 1;
		}
		
	}//end CBaseTeelos
}